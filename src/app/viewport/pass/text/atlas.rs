use crate::HashMap;
use serde::{Deserialize, Serialize};
use std::io::Read;

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub(super) enum AtlasType {
    #[serde(rename = "hardmask")]
    HardMask,
    #[serde(rename = "softmask")]
    SoftMask,
    #[serde(rename = "sdf")]
    Sdf,
    #[serde(rename = "psdf")]
    Psdf,
    #[serde(rename = "msdf")]
    Msdf,
    #[serde(rename = "mtsdf")]
    Mtsdf,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
enum YOrigin {
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "top")]
    Top,
}

#[derive(Debug, Serialize, Deserialize)]
struct AtlasInfo {
    #[serde(rename = "type")]
    atlas_type: AtlasType,
    #[serde(rename = "distanceRange")]
    distance_range: f32,
    #[serde(rename = "size")]
    size: f32,
    #[serde(rename = "width")]
    width: u32,
    #[serde(rename = "height")]
    height: u32,
    #[serde(rename = "yOrigin")]
    y_origin: YOrigin,
}

#[derive(Debug, Serialize, Deserialize)]
struct FontMetrics {
    #[serde(rename = "emSize")]
    em_size: f32,
    #[serde(rename = "lineHeight")]
    line_height: f32,
    #[serde(rename = "ascender")]
    ascender: f32,
    #[serde(rename = "descender")]
    descender: f32,
    #[serde(rename = "underlineY")]
    underline_y: f32,
    #[serde(rename = "underlineThickness")]
    underline_thickness: f32,
}

#[derive(Debug, Serialize, Deserialize)]
pub(super) struct Bounds {
    #[serde(rename = "left")]
    pub(super) left: f32,
    #[serde(rename = "top")]
    pub(super) top: f32,
    #[serde(rename = "right")]
    pub(super) right: f32,
    #[serde(rename = "bottom")]
    pub(super) bottom: f32,
}

#[derive(Debug, Serialize, Deserialize)]
struct GlyphInfo {
    #[serde(rename = "unicode")]
    unicode: u32,
    #[serde(rename = "advance")]
    advance: f32,
    #[serde(rename = "planeBounds")]
    plane_bounds: Option<Bounds>,
    #[serde(rename = "atlasBounds")]
    atlas_bounds: Option<Bounds>,
}

#[derive(Debug, Serialize, Deserialize)]
struct Kerning {
    #[serde(rename = "unicode1")]
    unicode1: u32,
    #[serde(rename = "unicode2")]
    unicode2: u32,
    #[serde(rename = "advance")]
    advance: f32,
}

#[derive(Debug, Serialize, Deserialize)]
struct FontInfo {
    #[serde(rename = "atlas")]
    atlas: AtlasInfo,
    #[serde(rename = "metrics")]
    metrics: FontMetrics,
    #[serde(rename = "glyphs")]
    glyphs: Box<[GlyphInfo]>,
    #[serde(rename = "kerning")]
    kerning: Box<[Kerning]>,
}

pub(super) struct GlyphSprite {
    pub(super) bounds: Bounds,
    pub(super) uv_bounds: Bounds,
}

pub(super) struct Glyph {
    pub(super) x_advance: f32,
    pub(super) sprite: Option<GlyphSprite>,
}

/// A font atlas as generated by https://github.com/Chlumsky/msdf-atlas-gen
#[allow(dead_code)]
pub(super) struct FontAtlas {
    pub(super) atlas_type: AtlasType,
    pub(super) line_height: f32,
    size: f32,
    distance_range: f32,
    glyphs: HashMap<char, Glyph>,
    kerning: HashMap<(char, char), f32>,
}

impl FontAtlas {
    pub(super) fn load<R: Read>(reader: R) -> std::io::Result<Self> {
        let info: FontInfo = serde_json::from_reader(reader)?;

        let atlas_type = info.atlas.atlas_type;
        let atlas_size = info.atlas.size;
        let distance_range = info.atlas.distance_range;
        let texture_width = info.atlas.width as f32;
        let texture_height = info.atlas.height as f32;
        let y_origin = info.atlas.y_origin;

        let em_size = info.metrics.em_size;
        let line_height = info.metrics.line_height / em_size;
        let base = (info.metrics.line_height - info.metrics.descender) / em_size;

        let mut glyphs = HashMap::default();

        for glyph in info.glyphs.iter() {
            if let Some(c) = char::from_u32(glyph.unicode) {
                let plane_bounds = glyph.plane_bounds.as_ref();
                let atlas_bounds = glyph.atlas_bounds.as_ref();

                let sprite =
                    Option::zip(plane_bounds, atlas_bounds).map(|(plane_bounds, atlas_bounds)| {
                        let mut bounds = Bounds {
                            top: (plane_bounds.top / em_size) + base,
                            bottom: (plane_bounds.bottom / em_size) + base,
                            left: plane_bounds.left / em_size,
                            right: plane_bounds.right / em_size,
                        };

                        let mut uv_bounds = Bounds {
                            top: atlas_bounds.top / texture_height,
                            bottom: atlas_bounds.bottom / texture_height,
                            left: atlas_bounds.left / texture_width,
                            right: atlas_bounds.right / texture_width,
                        };

                        // Move bounds such that the draw position is in the bottom left
                        bounds.top -= line_height;
                        bounds.bottom -= line_height;

                        // We have a bottom origin in the canvas but texture-coordinates have a top origin
                        match y_origin {
                            YOrigin::Bottom => {
                                // Flip texture coords
                                uv_bounds.top = 1.0 - uv_bounds.top;
                                uv_bounds.bottom = 1.0 - uv_bounds.bottom;
                            }
                            YOrigin::Top => {
                                // Flip bounds
                                bounds.top = -bounds.top;
                                bounds.bottom = -bounds.bottom;
                            }
                        }

                        GlyphSprite { bounds, uv_bounds }
                    });

                glyphs.insert(
                    c,
                    Glyph {
                        x_advance: glyph.advance / em_size,
                        sprite,
                    },
                );
            }
        }

        let mut kerning = HashMap::default();
        for k in info.kerning.iter() {
            if let (Some(c1), Some(c2)) = (char::from_u32(k.unicode1), char::from_u32(k.unicode2)) {
                kerning.insert((c1, c2), k.advance / info.metrics.em_size);
            }
        }

        Ok(Self {
            atlas_type,
            line_height,
            size: atlas_size,
            distance_range,
            glyphs,
            kerning,
        })
    }

    #[inline]
    pub(crate) fn get_distance_range(&self, font_size: f32) -> f32 {
        (font_size / self.size) * self.distance_range
    }

    #[inline]
    pub(super) fn get_glyph(&self, c: char) -> Option<&Glyph> {
        self.glyphs.get(&c)
    }

    pub(super) fn get_kerning(&self, lhs: Option<char>, rhs: char) -> f32 {
        lhs.and_then(|lhs| self.kerning.get(&(lhs, rhs)))
            .copied()
            .unwrap_or(0.0)
    }

    pub(super) fn measure_text(&self, text: &str) -> f32 {
        let mut width = 0.0;

        let mut prev: Option<char> = None;
        for c in text.chars() {
            if let Some(glyph) = self.get_glyph(c) {
                let kerning = self.get_kerning(prev, c);
                width += glyph.x_advance + kerning;
                prev = Some(c);
            }
        }

        width
    }
}
